// step 1 & step 2: Append Padding Bits and Append Length
// convert message to bits, text or file ensuring hat the message length % 512 = 448. we will append "0" bits to the end  of our message. A minimum we will only append one bit, and at most we will append 512bit
pub fn bit_padding(message: &str) -> Vec<u8> {
    // convert input to vec of u8
    let mut input_vector = convert_str_to_vec(message);

    // use BigUint to store the bit length
    let bit_length: u64 = (message.len() as u64) * 8u64;

    // 128_u8 is the equivalent of padding 1 as an unsigned 8-bit integer
    // with lower-order bits first
    input_vector.push(128_u8);
    //check if bit length % 512 is 448 (64 less than 512)
    while (input_vector.len() * 8) % 512 != 448 {
        input_vector.push(0_u8);
    }

    let length_bits_u8_array = split_u64_to_u8_array(bit_length);
    input_vector.extend(length_bits_u8_array);
    return input_vector;
}

// Manual Extraction Using Bitwise Operations:
pub fn split_u64_to_u8_array(value: u64) -> [u8; 8] {
    [
        value as u8,
        (value >> 8) as u8,
        (value >> 16) as u8,
        (value >> 24) as u8,
        (value >> 32) as u8,
        (value >> 40) as u8,
        (value >> 48) as u8,
        (value >> 56) as u8,
    ]
}

pub fn split_u64_to_u8_array2(value: u64) -> [u8; 8] {
    value.to_le_bytes() // Little-endian (low-order byte first)
}

/*
Four auxiliary functions that each take as input three 32-bit words and produce as output one 32-bit word
*/
// step 4
//  F(X,Y,Z) = XY v not(X) Z
pub fn f(x: u32, y: u32, z: u32) -> u32 {
    (x & y) | (!x & z)
}
// G(X,Y,Z) = XZ v Y not(Z)
pub fn g(x: u32, y: u32, z: u32) -> u32 {
    (x & z) | (y & !z)
}
//  H(X,Y,Z) = X xor Y xor Z
pub fn h(x: u32, y: u32, z: u32) -> u32 {
    (x) ^ (y ^ z)
}
// I(X,Y,Z) = Y xor (X v not(Z))
pub fn i(x: u32, y: u32, z: u32) -> u32 {
    (y) ^ (x | !z)
}

pub fn convert_str_to_vec(input: &str) -> Vec<u8> {
    return input.as_bytes().to_vec();
}

/**
* This function is specified in the rfc as a way to generate the
* table that we use in rounds 1-4 as part of the hashing operation.
* The function is specified as:
* T[i] = floor(2^32 * abs(sin(i+1)))
*/
pub fn sine_function_table_construction(i: u32) -> u32 {
    let i_clamped = std::cmp::max(1, std::cmp::min(i, 64)); // Clamp i between 1 and 64
    let x: f64 = i_clamped as f64;
    let sine_eval = x.sin().abs();
    // where 2^32 == 4294967296
    return (4294967296.0 * sine_eval) as u32;
}

// Terminologies:
/*
1. Low order byte: Represent the smallest part of the value.
2. High order byte: Represent the largest part of the value
3. sine function
*/

/* Round 1. */
/**
* Round 1 function is specified as 16 operations using the following:
* Let [abcd, k s i] denote the operation -
* a = b + ((a + f(b,c,d) + x[k] + table[i]) <<< s);
* where x[k] is a 32 bit chunk of our original message,
* table[i] is an entry generated by our sine function, s is an unsigned
* integer, and a,b,c,d are our 32 bit registers we perform operations on.
*/
fn round_one(
    mut a: u32,
    mut b: u32,
    mut c: u32,
    mut d: u32,
    table: &Vec<u32>,
    x: &Vec<u32>,
) -> [u32; 4] {
    macro_rules! round1 {
        ( $a:ident, $b:ident, $c:ident, $d:ident, $k:expr, $s:expr, $i: expr ) => {
            $a = $b.wrapping_add(
                ($a.wrapping_add(f($b, $c, $d))
                    .wrapping_add(x[$k])
                    .wrapping_add(table[$i]))
                .rotate_left($s),
            )
        };
    }

    round1!(a, b, c, d, 0, 7, 1);
    round1!(d, a, b, c, 1, 12, 2);
    round1!(c, d, a, b, 2, 17, 3);
    round1!(b, c, d, a, 3, 22, 4);

    round1!(a, b, c, d, 4, 7, 5);
    round1!(d, a, b, c, 5, 12, 6);
    round1!(c, d, a, b, 6, 17, 7);
    round1!(b, c, d, a, 7, 22, 8);

    round1!(a, b, c, d, 8, 7, 9);
    round1!(d, a, b, c, 9, 12, 10);
    round1!(c, d, a, b, 10, 17, 11);
    round1!(b, c, d, a, 11, 22, 12);

    round1!(a, b, c, d, 12, 7, 13);
    round1!(d, a, b, c, 13, 12, 14);
    round1!(c, d, a, b, 14, 17, 15);
    round1!(b, c, d, a, 15, 22, 16);

    return [a, b, c, d];
}

/**
* Round 2 is equivalent to round 1, except we swap out our f function for g as such:
* a = b + ((a + g(b,c,d) + x[k] + table[i]) <<< s);
*/
fn round_two(
    mut a: u32,
    mut b: u32,
    mut c: u32,
    mut d: u32,
    table: &Vec<u32>,
    x: &Vec<u32>,
) -> [u32; 4] {
    macro_rules! round2 {
        ( $a:ident, $b:ident, $c:ident, $d:ident, $k:expr, $s:expr, $i:expr) => {
            $a = $b.wrapping_add(
                ($a.wrapping_add(g($b, $c, $d))
                    .wrapping_add(x[$k])
                    .wrapping_add(table[$i]))
                .rotate_left($s),
            )
        };
    }

    round2!(a, b, c, d, 1, 5, 17);
    round2!(d, a, b, c, 6, 9, 18);
    round2!(c, d, a, b, 11, 14, 19);
    round2!(b, c, d, a, 0, 20, 20);

    round2!(a, b, c, d, 5, 5, 21);
    round2!(d, a, b, c, 10, 9, 22);
    round2!(c, d, a, b, 15, 14, 23);
    round2!(b, c, d, a, 4, 20, 24);

    round2!(a, b, c, d, 9, 5, 25);
    round2!(d, a, b, c, 14, 9, 26);
    round2!(c, d, a, b, 3, 14, 27);
    round2!(b, c, d, a, 8, 20, 28);

    round2!(a, b, c, d, 13, 5, 29);
    round2!(d, a, b, c, 2, 9, 30);
    round2!(c, d, a, b, 7, 14, 31);
    round2!(b, c, d, a, 12, 20, 32);

    return [a, b, c, d];
}

/**
* Round 3 is equivalent to round 1, except we swap out our f function for h as such:
* a = b + ((a + h(b,c,d) + x[k] + table[i]) <<< s);
*/
fn round_three(
    mut a: u32,
    mut b: u32,
    mut c: u32,
    mut d: u32,
    table: &Vec<u32>,
    x: &Vec<u32>,
) -> [u32; 4] {
    macro_rules! round3 {
        ( $a:ident, $b:ident, $c:ident, $d:ident, $k:expr, $s:expr, $i:expr  ) => {
            $a = $b.wrapping_add(
                ($a.wrapping_add(h($b, $c, $d))
                    .wrapping_add(x[$k])
                    .wrapping_add(table[$i]))
                .rotate_left($s),
            )
        };
    }

    round3!(a, b, c, d, 5, 4, 33);
    round3!(d, a, b, c, 8, 11, 34);
    round3!(c, d, a, b, 11, 16, 35);
    round3!(b, c, d, a, 14, 23, 36);

    round3!(a, b, c, d, 1, 4, 37);
    round3!(d, a, b, c, 4, 11, 38);
    round3!(c, d, a, b, 7, 16, 39);
    round3!(b, c, d, a, 10, 23, 40);

    round3!(a, b, c, d, 13, 4, 41);
    round3!(d, a, b, c, 0, 11, 42);
    round3!(c, d, a, b, 3, 16, 43);
    round3!(b, c, d, a, 6, 23, 44);

    round3!(a, b, c, d, 9, 4, 45);
    round3!(d, a, b, c, 12, 11, 46);
    round3!(c, d, a, b, 15, 16, 47);
    round3!(b, c, d, a, 2, 23, 48);

    return [a, b, c, d];
}

/**
* Round 4 is equivalent to round 1, except we swap out our f function for h as such:
* a = b + ((a + i(b,c,d) + x[k] + table[i]) <<< s);
*/
fn round_four(
    mut a: u32,
    mut b: u32,
    mut c: u32,
    mut d: u32,
    table: &Vec<u32>,
    x: &Vec<u32>,
) -> [u32; 4] {
    macro_rules! round4 {
        ( $a:ident, $b:ident, $c:ident, $d:ident, $k:expr, $s:expr, $i:expr ) => {
            $a = $b.wrapping_add(
                ($a.wrapping_add(i($b, $c, $d))
                    .wrapping_add(x[$k])
                    .wrapping_add(table[$i]))
                .rotate_left($s),
            )
        };
    }

    round4!(a, b, c, d, 0, 6, 49);
    round4!(d, a, b, c, 7, 10, 50);
    round4!(c, d, a, b, 14, 15, 51);
    round4!(b, c, d, a, 5, 21, 52);

    round4!(a, b, c, d, 12, 6, 53);
    round4!(d, a, b, c, 3, 10, 54);
    round4!(c, d, a, b, 10, 15, 55);
    round4!(b, c, d, a, 1, 21, 56);

    round4!(a, b, c, d, 8, 6, 57);
    round4!(d, a, b, c, 15, 10, 58);
    round4!(c, d, a, b, 6, 15, 59);
    round4!(b, c, d, a, 13, 21, 60);

    round4!(a, b, c, d, 4, 6, 61);
    round4!(d, a, b, c, 11, 10, 62);
    round4!(c, d, a, b, 2, 15, 63);
    round4!(b, c, d, a, 9, 21, 64);

    return [a, b, c, d];
}

pub fn md5_digest(mut value: Vec<u8>) -> String {
    // step 3: Initialize MD Buffer
    let mut word_a = 0x67452301u32;
    let mut word_b = 0xefcdab89u32;
    let mut word_c = 0x98badcfeu32;
    let mut word_d = 0x10325476u32;

    // table
    let table = construct_table_value();

    for chunk in value.chunks_exact_mut(64) {
        let x = u8_chunk_to_u32(chunk);
        // set all values of a,b,c,d to aa,bb,cc, and dd respectively.
        let word_aa = word_a;
        let word_bb = word_b;
        let word_cc = word_c;
        let word_dd = word_d;
        // execute round 1
        let result = round_one(word_a, word_b, word_c, word_d, &table, &x);
        word_a = result[0];
        word_b = result[1];
        word_c = result[2];
        word_d = result[3];

        // execute round 2
        let result = round_two(word_a, word_b, word_c, word_d, &table, &x);

        word_a = result[0];
        word_b = result[1];
        word_c = result[2];
        word_d = result[3];

        // execute round 3
        let result = round_three(word_a, word_b, word_c, word_d, &table, &x);
        word_a = result[0];
        word_b = result[1];
        word_c = result[2];
        word_d = result[3];

        // execute round 4
        let result = round_four(word_a, word_b, word_c, word_d, &table, &x);
        word_a = result[0];
        word_b = result[1];
        word_c = result[2];
        word_d = result[3];

        // at end of loop iteration, add original word
        // to the current word value
        word_a = word_a.wrapping_add(word_aa);
        word_b = word_b.wrapping_add(word_bb);
        word_c = word_c.wrapping_add(word_cc);
        word_d = word_d.wrapping_add(word_dd);
    }
    let message_digest = format!(
        "{:08x}{:08x}{:08x}{:08x}",
        word_a.swap_bytes(),
        word_b.swap_bytes(),
        word_c.swap_bytes(),
        word_d.swap_bytes()
    );
    return message_digest;
}

pub fn u8_chunk_to_u32(chunk: &mut [u8]) -> Vec<u32> {
    let mut vecu32: Vec<u32> = Vec::new();

    let length = chunk.len();
    let num_chunks = length / 4;

    //    iterate in steps of 4 bytes

    for i in 0..num_chunks {
        let start = i * 4;
        // convert the slice of 4 bytes into u32
        let value = u32::from_ne_bytes([
            chunk[start],
            chunk[start + 1],
            chunk[start + 2],
            chunk[start + 3],
        ]);

        vecu32.push(value);
    }
    vecu32
}

pub fn construct_table_value() -> Vec<u32> {
    let mut value: Vec<u32> = Vec::new();
    value.push(0x00000000);
    for i in 1..=64 {
        value.push(sine_function_table_construction(i));
    }
    value
}

pub fn md5(message: &str) -> String {
    let input_vec = bit_padding(message);
    return md5_digest(input_vec);
}
